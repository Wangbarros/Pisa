table(res_df$RF, res_df$Target)
table(res_df$Elastic, res_df$Target)
table(res_df$Elastic, res_df$RF)
note
MLmetrics::Accuracy(res_df$RF,res_df$Target)
MLmetrics::F1_Score(res_df$RF,res_df$Target)
mltools::mcc(res_df$RF,res_df$Target)
load("~/Dropbox/PostDoc/Karolinska/Sapient/Results/future_prediction_2025-11-07-01-03.RData")
note <- reslist_n_rep$note
reslist_n_rep$note = NULL
note
res_df = data.frame(RF = character(), better_prob = character(), equal_worse_prob = character(),
Elastic = character(), Target = character())
RF_df = data.frame(mtry = character(), split = character(), min_node = character())
elastic_df = data.frame(alpha = character(), lambda = character())
i=1
reslist_n_rep[[15]]$rf_res$best_mtry
reslist_n_rep[[15]]$rf_res$probabilities_one
reslist_n_rep[[i]]$elastic_res$best_l1_l2
# a = (caret::varImp(rf_res$model))
# imp_df = a$importance
# setwd("~/Downloads")
# write.csv(imp_df, file='metabolites_imp_all.csv')
#setwd("~/Documents/1) Postdoc data/Karolinska/Sapient")
#final_df = read.csv('8m_rlc_imputted_rows.csv')
pfun <- function(object, newdata) {
predict(object, newdata = newdata, type = "prob")[,1] # prob of first class
}
# Approximate SHAP values (nsim controls accuracy vs. speed)
shap_values <- fastshap::explain(rf_res$model, X = df, pred_wrapper = pfun, nsim = 100)
# Variable importance = mean absolute SHAP
shap_importance <- sort(colMeans(abs(shap_values)), decreasing = TRUE)
for (i in 1:length(reslist_n_rep)){
res_df[i,1] = as.character(reslist_n_rep[[i]]$rf_res$prediction_one)
res_df[i,2] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Better)
res_df[i,3] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Equal.Worse)
# res_df[i,2] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Mild)
# res_df[i,3] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Moderate)
# res_df[i,4] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Severe)
# res_df[i,5] = as.character(reslist_n_rep[[i]]$elastic_res$prediction_one)
# res_df[i,6] = as.character(reslist_n_rep[[i]]$rf_res$target_one)
#
res_df[i,4] = as.character(reslist_n_rep[[i]]$elastic_res$prediction_one)
res_df[i,5] = as.character(reslist_n_rep[[i]]$rf_res$target_one)
RF_df[i,] = reslist_n_rep[[i]]$rf_res$best_mtry
elastic_df[i,] = reslist_n_rep[[i]]$elastic_res$best_l1_l2
}
table(res_df$RF, res_df$Target)
table(res_df$Elastic, res_df$Target)
table(res_df$Elastic, res_df$RF)
note
MLmetrics::Accuracy(res_df$RF,res_df$Target)
load("~/Dropbox/PostDoc/Karolinska/Sapient/Results/future_prediction_2025-11-07-00-16.RData")
note <- reslist_n_rep$note
reslist_n_rep$note = NULL
note
res_df = data.frame(RF = character(), better_prob = character(), equal_worse_prob = character(),
Elastic = character(), Target = character())
RF_df = data.frame(mtry = character(), split = character(), min_node = character())
elastic_df = data.frame(alpha = character(), lambda = character())
i=1
reslist_n_rep[[15]]$rf_res$best_mtry
reslist_n_rep[[15]]$rf_res$probabilities_one
reslist_n_rep[[i]]$elastic_res$best_l1_l2
# a = (caret::varImp(rf_res$model))
# imp_df = a$importance
# setwd("~/Downloads")
# write.csv(imp_df, file='metabolites_imp_all.csv')
#setwd("~/Documents/1) Postdoc data/Karolinska/Sapient")
#final_df = read.csv('8m_rlc_imputted_rows.csv')
pfun <- function(object, newdata) {
predict(object, newdata = newdata, type = "prob")[,1] # prob of first class
}
# Approximate SHAP values (nsim controls accuracy vs. speed)
shap_values <- fastshap::explain(rf_res$model, X = df, pred_wrapper = pfun, nsim = 100)
# Variable importance = mean absolute SHAP
shap_importance <- sort(colMeans(abs(shap_values)), decreasing = TRUE)
for (i in 1:length(reslist_n_rep)){
res_df[i,1] = as.character(reslist_n_rep[[i]]$rf_res$prediction_one)
res_df[i,2] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Better)
res_df[i,3] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Equal.Worse)
# res_df[i,2] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Mild)
# res_df[i,3] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Moderate)
# res_df[i,4] = as.character(reslist_n_rep[[i]]$rf_res$probabilities_one$Severe)
# res_df[i,5] = as.character(reslist_n_rep[[i]]$elastic_res$prediction_one)
# res_df[i,6] = as.character(reslist_n_rep[[i]]$rf_res$target_one)
#
res_df[i,4] = as.character(reslist_n_rep[[i]]$elastic_res$prediction_one)
res_df[i,5] = as.character(reslist_n_rep[[i]]$rf_res$target_one)
RF_df[i,] = reslist_n_rep[[i]]$rf_res$best_mtry
elastic_df[i,] = reslist_n_rep[[i]]$elastic_res$best_l1_l2
}
table(res_df$RF, res_df$Target)
table(res_df$Elastic, res_df$Target)
table(res_df$Elastic, res_df$RF)
note
MLmetrics::Accuracy(res_df$RF,res_df$Target)
MLmetrics::F1_Score(res_df$RF,res_df$Target)
setwd("~/Dropbox/PostDoc/Pisa")
df2022 = read.csv("data/df2022_filtered.csv")
df2022 <- df2022 %>%
select(-starts_with("FL"), -starts_with("WB"))
names(df2022)
df2022$CNT = as.factor(df2022$CNT)
unique(df2022$CNT)
df2022$MATH = (df2022$PV1MATH + df2022$PV2MATH + df2022$PV3MATH + df2022$PV4MATH + df2022$PV5MATH
+ df2022$PV6MATH + df2022$PV7MATH + df2022$PV8MATH + df2022$PV9MATH + df2022$PV10MATH)/10
contrasts(df2022$CNT) <- contr.sum
df2022$CNT <- factor(df2022$CNT)
model_1 = lm(MATH ~ CNT + ESCS + CNT*ESCS, data = df2022, weights = W_FSTUWT)
summary(model_1)
emtrends(model_1, ~ CNT, var = "ESCS")
plot(emtrends(model_1, ~ CNT, var = "ESCS") )
pred_data <- df2022 %>%
group_by(CNT) %>%
summarise(ESCS_min = min(ESCS, na.rm = TRUE),
ESCS_max = max(ESCS, na.rm = TRUE)) %>%
rowwise() %>%
do(data.frame(CNT = .$CNT, ESCS = seq(.$ESCS_min, .$ESCS_max, length.out = 100))) %>%
ungroup()
# Add predictions from the weighted model
pred_data$MATH_pred <- predict(model_1, newdata = pred_data)
ggplot(df2022, aes(x = ESCS, y = MATH, color = CNT)) +
geom_point(aes(weight = W_FSTUWT), alpha = 0.2) +
geom_line(data = pred_data, aes(y = MATH_pred), size = 1) +
theme_minimal() +
labs(x = "ESCS", y = "Predicted MATH score", color = "Country")
ggplot(df2022, aes(x = ESCS, y = MATH, color = CNT)) +
#geom_point(aes(weight = W_FSTUWT), alpha = 0.2) +
geom_line(data = pred_data, aes(y = MATH_pred), size = 1) +
theme_minimal() +
labs(x = "ESCS", y = "Predicted MATH score", color = "Country")
?emtrends
names(df2022)
fit_with_weights <- function(df, weight_col, grid_n = 100) {
# Extract weight vector dynamically
df <- df %>% mutate(W = .data[[weight_col]])
# Fit weighted model
model <- lm(MATH ~ CNT * ESCS, data = df, weights = W)
# Country-specific slope of ESCS (wealth effect)
trends <- as.data.frame(emtrends(model, ~ CNT, var = "ESCS"))
# Build prediction grid per country
grid <- df %>%
group_by(CNT) %>%
summarise(
ESCS_min = min(ESCS, na.rm = TRUE),
ESCS_max = max(ESCS, na.rm = TRUE),
.groups = "drop"
) %>%
rowwise() %>%
do(data.frame(
CNT = .$CNT,
ESCS = seq(.$ESCS_min, .$ESCS_max, length.out = grid_n)
)) %>%
ungroup()
# Predictions
grid$MATH_pred <- predict(model, newdata = grid)
# Return everything neatly
list(
weight_name = weight_col,
model = model,
emtrends = trends,
predictions = grid
)
}
setwd("~/Dropbox/PostDoc/Pisa")
source(fit_with_weights)
source("fit_with_weights.R")
result <- fit_with_weights(df2022, outcome_var = "MATH", weight_col = "W_FSTUWT")
result$emtrends
plot(result$emtrends )
library(survey)
?svrepdesign
pisa_design <- svrepdesign(
weights = ~W_FSTUWT,
repweights = df2022[, rep_weights],
data = df2022,
type = "BRR",
fay.r = 0.5,   # Fay's adjustment
mse = TRUE
)
rep_weights <- paste0("W_FSTUWT", 1:80)
pisa_design <- svrepdesign(
weights = ~W_FSTUWT,
repweights = df2022[, rep_weights],
data = df2022,
type = "BRR",
fay.r = 0.5,   # Fay's adjustment
mse = TRUE
)
rep_weights
names(df2022)
rep_weights
rep_weights <- paste0("W_FSTUWT", 1:80)
pisa_design <- svrepdesign(
weights = ~W_FSTUWT,
repweights = df2022[, rep_weights],
data = df2022,
type = "BRR",
fay.r = 0.5,   # Fay's adjustment
mse = TRUE
)
names(df2022)
rep_weights <- paste0("W_FSTURWT", 1:80)
pisa_design <- svrepdesign(
weights = ~W_FSTUWT,
repweights = df2022[, rep_weights],
data = df2022,
type = "BRR",
fay.r = 0.5,   # Fay's adjustment
mse = TRUE
)
form <- MATH ~ CNT * ESCS  # change MATH to your outcome
svy_model <- svyglm(form, design = pisa_design)
coefs <- coef(svy_model)
coefs
# 95% confidence intervals (using replicate-based variance)
ci <- confint(svy_model)
data.frame(
term = names(coefs),
estimate = coefs,
lower = ci[,1],
upper = ci[,2]
)
slopes <- emtrends(svy_model, ~ CNT, var = "ESCS") %>% as.data.frame()
slopes
plot(slopes)
svy_model
emtrends
?emtrends
intercepts <- emmeans(svy_model, ~ CNT, at = list(ESCS = 0)) %>% as.data.frame()
plot(intercepts)
result <- fit_with_weights(df2022, outcome_var = "MATH", weight_col = "W_FSTUWT")
slopes <- emtrends(svy_model, ~ CNT, var = "ESCS") %>% as.data.frame()
intercepts <- emmeans(svy_model, ~ CNT, at = list(ESCS = 0)) %>% as.data.frame()
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE.trend, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE.trend,
slope_lower = lower.CL,
slope_upper = upper.CL
) %>%
left_join(
intercepts_df %>%
select(CNT, emmean, SE, lower.CL, upper.CL) %>%
rename(
intercept = emmean,
intercept_SE = SE,
intercept_lower = lower.CL,
intercept_upper = upper.CL
),
by = "CNT"
)
slopes_df <- emtrends(svy_model, ~ CNT, var = "ESCS") %>% as.data.frame()
intercepts_df <- emmeans(svy_model, ~ CNT, at = list(ESCS = 0)) %>% as.data.frame()
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE.trend, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE.trend,
slope_lower = lower.CL,
slope_upper = upper.CL
) %>%
left_join(
intercepts_df %>%
select(CNT, emmean, SE, lower.CL, upper.CL) %>%
rename(
intercept = emmean,
intercept_SE = SE,
intercept_lower = lower.CL,
intercept_upper = upper.CL
),
by = "CNT"
)
slopes_df
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE.trend,
slope_lower = lower.CL,
slope_upper = upper.CL
) %>%
left_join(
intercepts_df %>%
select(CNT, emmean, SE, lower.CL, upper.CL) %>%
rename(
intercept = emmean,
intercept_SE = SE,
intercept_lower = lower.CL,
intercept_upper = upper.CL
),
by = "CNT"
)
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE
slope_lower = lower.CL,
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE,
slope_lower = lower.CL,
slope_upper = upper.CL
) %>%
left_join(
intercepts_df %>%
select(CNT, emmean, SE, lower.CL, upper.CL) %>%
rename(
intercept = emmean,
intercept_SE = SE,
intercept_lower = lower.CL,
intercept_upper = upper.CL
),
by = "CNT"
)
grid_n <- 100
pred_grid <- coef_df %>%
rowwise() %>%
do(data.frame(
CNT = .$CNT,
ESCS = seq(min(df2022$ESCS, na.rm = TRUE), max(df2022$ESCS, na.rm = TRUE), length.out = grid_n),
slope = .$slope,
intercept = .$intercept,
slope_SE = .$slope_SE,
intercept_SE = .$intercept_SE
)) %>%
ungroup() %>%
mutate(
MATH_pred = intercept + slope * ESCS
)
pred_grid <- pred_grid %>%
mutate(
lower = MATH_pred - 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2),
upper = MATH_pred + 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2)
)
ggplot(pred_grid, aes(x = ESCS, y = MATH_pred, color = CNT, fill = CNT)) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = NA) +
theme_minimal() +
labs(
x = "ESCS",
y = "Predicted MATH",
title = "Predicted MATH vs ESCS by Country",
color = "Country",
fill = "Country"
)
plot(slopes_df)
?svyglm
form
svy_model
setwd("~/Dropbox/PostDoc/Pisa")
df2022 = read.csv("data/df2022.csv")
df2022 <- df2022 %>%
select(-starts_with("FL"), -starts_with("WB"))
names(df2022)
df2022$CNT = as.factor(df2022$CNT)
unique(df2022$CNT)
df2022$MATH = (df2022$PV1MATH + df2022$PV2MATH + df2022$PV3MATH + df2022$PV4MATH + df2022$PV5MATH
+ df2022$PV6MATH + df2022$PV7MATH + df2022$PV8MATH + df2022$PV9MATH + df2022$PV10MATH)/10
contrasts(df2022$CNT) <- contr.sum
df2022$CNT <- factor(df2022$CNT)
rep_weights <- paste0("W_FSTURWT", 1:80)
pisa_design <- svrepdesign(
weights = ~W_FSTUWT,
repweights = df2022[, rep_weights],
data = df2022,
type = "BRR",
fay.r = 0.5,   # Fay's adjustment
mse = TRUE
)
form <- MATH ~ CNT * ESCS
svy_model <- svyglm(form, design = pisa_design)
coefs <- coef(svy_model)
ci <- confint(svy_model)
data.frame(
term = names(coefs),
estimate = coefs,
lower = ci[,1],
upper = ci[,2]
)
slopes_df <- emtrends(svy_model, ~ CNT, var = "ESCS") %>% as.data.frame()
intercepts_df <- emmeans(svy_model, ~ CNT, at = list(ESCS = 0)) %>% as.data.frame()
plot(intercepts_df)
plot(slopes_df)
ggplot(coef_df, aes(x = intercept, y = slope, label = CNT)) +
geom_point() +
geom_text(nudge_y = 0.02, size = 3) +
geom_errorbar(aes(ymin = slope_lower, ymax = slope_upper), width = 0) +
geom_errorbarh(aes(xmin = intercept_lower, xmax = intercept_upper), height = 0) +
theme_minimal() +
labs(x = "Intercept (ESCS = 0)", y = "Slope (Effect of ESCS on MATH)",
title = "Country-level intercepts and slopes")
coef_df <- slopes_df %>%
select(CNT, ESCS.trend, SE, lower.CL, upper.CL) %>%
rename(
slope = ESCS.trend,
slope_SE = SE,
slope_lower = lower.CL,
slope_upper = upper.CL
) %>%
left_join(
intercepts_df %>%
select(CNT, emmean, SE, lower.CL, upper.CL) %>%
rename(
intercept = emmean,
intercept_SE = SE,
intercept_lower = lower.CL,
intercept_upper = upper.CL
),
by = "CNT"
)
grid_n <- 100
pred_grid <- coef_df %>%
rowwise() %>%
do(data.frame(
CNT = .$CNT,
ESCS = seq(min(df2022$ESCS, na.rm = TRUE), max(df2022$ESCS, na.rm = TRUE), length.out = grid_n),
slope = .$slope,
intercept = .$intercept,
slope_SE = .$slope_SE,
intercept_SE = .$intercept_SE
)) %>%
ungroup() %>%
mutate(
MATH_pred = intercept + slope * ESCS
)
pred_grid <- pred_grid %>%
mutate(
lower = MATH_pred - 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2),
upper = MATH_pred + 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2)
)
ggplot(pred_grid, aes(x = ESCS, y = MATH_pred, color = CNT, fill = CNT)) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = NA) +
theme_minimal() +
labs(
x = "ESCS",
y = "Predicted MATH",
title = "Predicted MATH vs ESCS by Country",
color = "Country",
fill = "Country"
)
ggplot(coef_df, aes(x = intercept, y = slope, label = CNT)) +
geom_point() +
geom_text(nudge_y = 0.02, size = 3) +
geom_errorbar(aes(ymin = slope_lower, ymax = slope_upper), width = 0) +
geom_errorbarh(aes(xmin = intercept_lower, xmax = intercept_upper), height = 0) +
theme_minimal() +
labs(x = "Intercept (ESCS = 0)", y = "Slope (Effect of ESCS on MATH)",
title = "Country-level intercepts and slopes")
ggplot(coef_df, aes(x = intercept, y = slope, label = CNT)) +
geom_point() +
geom_text(nudge_y = -0.5, size = 3) +
geom_errorbar(aes(ymin = slope_lower, ymax = slope_upper), width = 0) +
geom_errorbarh(aes(xmin = intercept_lower, xmax = intercept_upper), height = 0) +
theme_minimal() +
labs(x = "Intercept (ESCS = 0)", y = "Slope (Effect of ESCS on MATH)",
title = "Country-level intercepts and slopes")
ggplot(coef_df, aes(x = intercept, y = slope, label = CNT)) +
geom_point() +
geom_text(nudge_y = -1, size = 3) +
geom_errorbar(aes(ymin = slope_lower, ymax = slope_upper), width = 0) +
geom_errorbarh(aes(xmin = intercept_lower, xmax = intercept_upper), height = 0) +
theme_minimal() +
labs(x = "Intercept (ESCS = 0)", y = "Slope (Effect of ESCS on MATH)",
title = "Country-level intercepts and slopes")
ggplot(pred_grid, aes(x = ESCS, y = MATH_pred, color = CNT, fill = CNT)) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = NA) +
theme_minimal() +
labs(
x = "ESCS",
y = "Predicted MATH",
title = "Predicted MATH vs ESCS by Country",
color = "Country",
fill = "Country"
)
pred_grid <- pred_grid %>%
mutate(
lower = MATH_pred - 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2),
upper = MATH_pred + 1.96 * sqrt(intercept_SE^2 + (ESCS^2) * slope_SE^2)
)
pred_grid
coef_df
plot(intercepts_df)
slopes_df <- emtrends(svy_model, ~ CNT, var = "ESCS") %>% as.data.frame()
slopes_df
result
result = data.frame(
term = names(coefs),
estimate = coefs,
lower = ci[,1],
upper = ci[,2]
)
result
coefs
ci
ci <- confint(svy_model)
ci
ggplot(coef_df, aes(x = intercept, y = slope, label = CNT)) +
geom_point() +
geom_text(nudge_y = -1, size = 3) +
geom_errorbar(aes(ymin = slope_lower, ymax = slope_upper), width = 0) +
geom_errorbarh(aes(xmin = intercept_lower, xmax = intercept_upper), height = 0) +
theme_minimal() +
labs(x = "Intercept (ESCS = 0)", y = "Slope (Effect of ESCS on MATH)",
title = "Country-level intercepts and slopes")
